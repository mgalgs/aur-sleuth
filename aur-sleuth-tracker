#!/usr/bin/env -S uv --quiet run --script
# -*- mode: python -*-
# /// script
# requires-python = "==3.12"
# dependencies = [
#     "openai",
#     "rich",
#     "requests",
# ]
# ///

import argparse
import concurrent.futures
import os
import random
import sqlite3
import subprocess
import sys
import tempfile
import time
from pathlib import Path
from typing import List, Tuple, Optional

# Assuming aur-sleuth is in the same directory
AUR_SLEUTH_PATH = Path(__file__).parent / "aur-sleuth"

FREE_MODELS = [
    'deepseek/deepseek-chat-v3.1:free',
    'openai/gpt-oss-120b:free',
    'z-ai/glm-4.5-air:free',
    'qwen/qwen3-coder:free',
    'moonshotai/kimi-k2:free',
    'deepseek/deepseek-r1-0528:free'
]


class AurTracker:
    def __init__(
        self,
        db_path: Path,
        aur_repo_path: Path,
        max_parallel: int = 3,
        max_packages: Optional[int] = None,
        second_opinions_mode: bool = False,
    ):
        self.db_path = db_path
        self.aur_repo_path = aur_repo_path
        self.max_parallel = max_parallel
        self.max_packages = max_packages
        self.second_opinions_mode = second_opinions_mode
        self.init_db()

    def init_db(self):
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS packages (
                    name TEXT PRIMARY KEY,
                    last_updated INTEGER,
                    status TEXT DEFAULT 'pending'
                )
            """)
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS audits (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    package_name TEXT,
                    started_at INTEGER,
                    finished_at INTEGER,
                    result TEXT,
                    details TEXT,
                    model TEXT,
                    git_rev TEXT,
                    version TEXT,
                    FOREIGN KEY (package_name) REFERENCES packages (name)
                )
            """)
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS audit_files (
                    audit_id INTEGER,
                    file_path TEXT,
                    status TEXT,
                    summary TEXT,
                    details TEXT,
                    FOREIGN KEY (audit_id) REFERENCES audits (id)
                )
            """
            )

    def update_aur_repo(self):
        if not self.aur_repo_path.exists():
            subprocess.run(
                [
                    "git",
                    "clone",
                    "https://aur.archlinux.org/aur.git",
                    self.aur_repo_path,
                ],
                check=True,
            )
        else:
            # Check if bare repo
            result = subprocess.run(
                ["git", "config", "--bool", "core.bare"],
                cwd=self.aur_repo_path,
                capture_output=True,
                text=True,
            )
            is_bare = result.returncode == 0 and result.stdout.strip() == "true"
            if is_bare:
                subprocess.run(
                    ["git", "fetch", "--all"], cwd=self.aur_repo_path, check=True
                )
            else:
                subprocess.run(["git", "pull"], cwd=self.aur_repo_path, check=True)

    def get_refs_with_dates(self) -> List[Tuple[str, str, int]]:
        # Try refs/heads first
        result = subprocess.run(
            [
                "git",
                "for-each-ref",
                "--format=%(refname) %(committerdate:unix) %(objectname)",
                "refs/heads",
            ],
            cwd=self.aur_repo_path,
            capture_output=True,
            text=True,
            check=True,
        )
        print(f"refs/heads: {len(result.stdout.strip().split('\n'))} refs")
        refs = []
        for line in result.stdout.strip().split("\n"):
            if line:
                parts = line.split()
                if len(parts) >= 3:
                    full_ref, date, rev = parts[0], int(parts[1]), parts[2]
                    ref_short = full_ref.split("/", 2)[
                        -1
                    ]  # Get the short name after refs/heads/
                    if ref_short.startswith("packages/"):
                        package_name = ref_short[len("packages/") :]
                    else:
                        package_name = ref_short
                    refs.append((ref_short, package_name, date, rev))

        # If few refs/heads, try refs/remotes/origin
        if len(refs) < 1000:
            result = subprocess.run(
                [
                    "git",
                    "for-each-ref",
                    "--format=%(refname) %(committerdate:unix) %(objectname)",
                    "refs/remotes/origin",
                ],
                cwd=self.aur_repo_path,
                capture_output=True,
                text=True,
                check=True,
            )
            print(f"refs/remotes/origin: {len(result.stdout.strip().split('\n'))} refs")
            for line in result.stdout.strip().split("\n"):
                if line:
                    parts = line.split()
                    if len(parts) >= 3:
                        full_ref, date, rev = parts[0], int(parts[1]), parts[2]
                        ref_short = full_ref.split("/", 3)[
                            -1
                        ]  # After refs/remotes/origin/
                        if ref_short.startswith("packages/"):
                            package_name = ref_short[len("packages/") :]
                        else:
                            package_name = ref_short
                        refs.append((ref_short, package_name, date, rev))

        # Filter out invalid package names
        valid_refs = []
        invalid_names = {'HEAD', 'master', 'main', 'develop', 'trunk', 'stable'}
        for ref_short, package_name, date, rev in refs:
            if package_name not in invalid_names and '/' not in package_name:
                valid_refs.append((ref_short, package_name, date, rev))
        print(f"Found {len(valid_refs)} valid refs")
        return sorted(valid_refs, key=lambda x: x[2], reverse=True)  # Most recent first

    def is_package_audited(self, package_name: str, git_rev: str) -> bool:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "SELECT 1 FROM audits WHERE package_name = ? AND git_rev = ?", (package_name, git_rev)
            )
            row = cursor.fetchone()
            return row is not None

    def mark_package_auditing(self, package_name: str, last_updated: int):
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                "INSERT OR REPLACE INTO packages (name, last_updated, status) VALUES (?, ?, ?)",
                (package_name, last_updated, "auditing"),
            )

    def audit_package(
        self, ref: str, package_name: str, last_updated: int, git_rev: str, model: str
    ) -> Tuple[str, dict]:
        started_at = int(time.time())
        tmpdir = Path(tempfile.mkdtemp())
        try:
            # Select model for second-opinions-mode
            if self.second_opinions_mode:
                with sqlite3.connect(self.db_path) as conn:
                    used_models = conn.execute("SELECT DISTINCT model FROM audits WHERE package_name = ? AND git_rev = ?", (package_name, git_rev)).fetchall()
                    used_models = {row[0] for row in used_models}
                    available_models = [m for m in FREE_MODELS if m not in used_models]
                    if available_models:
                        model = random.choice(available_models)
                    # else keep the passed model

            # Get aur-sleuth version
            version_result = subprocess.run(
                [str(AUR_SLEUTH_PATH), "--version"],
                capture_output=True,
                text=True,
                check=True,
            )
            aur_sleuth_version = version_result.stdout.strip()

            # Create worktree for the package
            subprocess.run(
                ["git", "worktree", "add", str(tmpdir), f"remotes/origin/{package_name}"],
                cwd=self.aur_repo_path,
                check=True,
            )

            # Get the actual git rev from the worktree
            rev_result = subprocess.run(
                ["git", "rev-parse", "HEAD"],
                cwd=tmpdir,
                capture_output=True,
                text=True,
                check=True,
            )
            actual_git_rev = rev_result.stdout.strip()

            # Run aur-sleuth with local clone_url and plain output
            result = subprocess.run(
                [
                    str(AUR_SLEUTH_PATH),
                    "--clone-url",
                    str(tmpdir),
                    "--output",
                    "plain",
                    package_name,
                ],
                capture_output=True,
                text=True,
            )

            finished_at = int(time.time())

            # Parse result
            output = result.stdout
            if 'Audit complete! Result: No issues found' in output:
                audit_result = 'safe'
            elif 'Audit complete! Result: Issues found' in output:
                audit_result = 'unsafe'
            else:
                audit_result = f'error: {output}'

            details = output

            return package_name, {
                "result": audit_result,
                "details": details,
                "model": model,
                "git_rev": actual_git_rev,
                "version": aur_sleuth_version,
                "started_at": started_at,
                "finished_at": finished_at,
            }
        except subprocess.CalledProcessError as e:
            finished_at = int(time.time())
            return package_name, {
                "result": f'error: {e.stderr}',
                "details": '',
                "model": model,
                "git_rev": git_rev,
                "version": "unknown",
                "started_at": started_at,
                "finished_at": finished_at,
            }
        finally:
            # Remove worktree
            subprocess.run(["git", "worktree", "remove", str(tmpdir)], cwd=self.aur_repo_path, check=False)
            import shutil
            shutil.rmtree(tmpdir, ignore_errors=True)

    def store_audit_result(
        self, package_name: str, last_updated: int, audit_data: dict
    ):
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                "UPDATE packages SET status = 'audited', last_updated = ? WHERE name = ?",
                (last_updated, package_name)
            )
            conn.execute(
                "INSERT INTO audits (package_name, started_at, finished_at, result, details, model, git_rev, version) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                (
                    package_name,
                    audit_data["started_at"],
                    audit_data["finished_at"],
                    audit_data["result"],
                    audit_data["details"],
                    audit_data["model"],
                    audit_data["git_rev"],
                    audit_data["version"],
                ),
            )

    def run_audit_loop(self):
        print("Updating AUR repo...")
        self.update_aur_repo()
        print("Getting refs...")
        refs = self.get_refs_with_dates()
        print(f"Found {len(refs)} refs")
        current_model = os.environ.get('OPENAI_MODEL', 'qwen/qwen3-235b-a22b-2507')
        candidates = []
        if not self.second_opinions_mode:
            for ref, package_name, date, git_rev in refs:
                if not self.is_package_audited(package_name, git_rev):
                    candidates.append((ref, package_name, date, git_rev))
        else:
            for ref, package_name, date, git_rev in refs:
                with sqlite3.connect(self.db_path) as conn:
                    audits = conn.execute("SELECT result, model FROM audits WHERE package_name = ? AND git_rev = ?", (package_name, git_rev)).fetchall()
                    if audits and any(a[0] != 'safe' for a in audits) and all(a[1] != current_model for a in audits):
                        candidates.append((ref, package_name, date, git_rev))
        if self.max_packages:
            candidates = sorted(candidates, key=lambda x: x[2], reverse=True)[:self.max_packages]
        print(f"Processing {len(candidates)} packages.")

        with concurrent.futures.ThreadPoolExecutor(
            max_workers=self.max_parallel
        ) as executor:
            futures = []
            for ref, package_name, date, git_rev in candidates:
                print(f"Queueing audit for {package_name}")
                self.mark_package_auditing(package_name, date)
                futures.append(
                    executor.submit(
                        self.audit_package, ref, package_name, date, git_rev, current_model
                    )
                )

            for future in concurrent.futures.as_completed(futures):
                try:
                    package_name, audit_data = future.result()
                    # Find last_updated for this package
                    last_updated = next(
                        (date for r, name, date, rev in refs if name == package_name), None
                    )
                    if last_updated:
                        self.store_audit_result(package_name, last_updated, audit_data)
                    print(f"Audit completed for {package_name}: {audit_data['result']}")
                except Exception as e:
                    print(f"Audit failed: {e}")


def main():
    parser = argparse.ArgumentParser(
        description="Track and audit AUR packages using aur-sleuth."
    )
    parser.add_argument(
        "--db-path", default="aur_tracker.db", help="Path to SQLite database"
    )
    parser.add_argument(
        "--aur-repo-path", default="aur-repo", help="Path to local AUR git repo"
    )
    parser.add_argument(
        "--max-parallel", type=int, default=3, help="Maximum parallel audits"
    )
    parser.add_argument(
        "--max-packages",
        type=int,
        help="Maximum number of packages to audit (for testing)",
    )
    parser.add_argument(
        "--im-feeling-lucky-freebiez",
        action="store_true",
        help="Select a random free LLM model from OpenRouter",
    )
    parser.add_argument(
        "--second-opinions-mode",
        action="store_true",
        help="Audit packages that failed previous audits with a different model",
    )
    args = parser.parse_args()

    if args.im_feeling_lucky_freebiez:
        selected_model = random.choice(FREE_MODELS)
        os.environ['OPENAI_MODEL'] = selected_model
        print(f"Selected random free model: {selected_model}")

    db_path = Path(args.db_path)
    aur_repo_path = Path(os.path.expanduser(args.aur_repo_path))

    tracker = AurTracker(db_path, aur_repo_path, args.max_parallel, args.max_packages, args.second_opinions_mode)
    tracker.run_audit_loop()


if __name__ == "__main__":
    main()
