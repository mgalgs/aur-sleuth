#!/usr/bin/env -S uv --quiet run --script
# -*- mode: python -*-
# /// script
# requires-python = "==3.12"
# dependencies = [
#     "openai",
#     "rich",
#     "requests",
# ]
# ///

import argparse
import concurrent.futures
import os
import sqlite3
import subprocess
import sys
import tempfile
import time
from pathlib import Path
from typing import List, Tuple, Optional

# Assuming aur-sleuth is in the same directory
AUR_SLEUTH_PATH = Path(__file__).parent / "aur-sleuth"


class AurTracker:
    def __init__(
        self,
        db_path: Path,
        aur_repo_path: Path,
        max_parallel: int = 3,
        max_packages: Optional[int] = None,
    ):
        self.db_path = db_path
        self.aur_repo_path = aur_repo_path
        self.max_parallel = max_parallel
        self.max_packages = max_packages
        self.init_db()

    def init_db(self):
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS packages (
                    name TEXT PRIMARY KEY,
                    last_updated INTEGER,
                    status TEXT DEFAULT 'pending'
                )
            """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS audits (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    package_name TEXT,
                    started_at INTEGER,
                    finished_at INTEGER,
                    result TEXT,
                    details TEXT,
                    FOREIGN KEY (package_name) REFERENCES packages (name)
                )
            """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS audit_files (
                    audit_id INTEGER,
                    file_path TEXT,
                    status TEXT,
                    summary TEXT,
                    details TEXT,
                    FOREIGN KEY (audit_id) REFERENCES audits (id)
                )
            """
            )

    def update_aur_repo(self):
        if not self.aur_repo_path.exists():
            subprocess.run(
                [
                    "git",
                    "clone",
                    "https://aur.archlinux.org/aur.git",
                    self.aur_repo_path,
                ],
                check=True,
            )
        else:
            # Check if bare repo
            result = subprocess.run(
                ["git", "config", "--bool", "core.bare"],
                cwd=self.aur_repo_path,
                capture_output=True,
                text=True,
            )
            is_bare = result.returncode == 0 and result.stdout.strip() == "true"
            if is_bare:
                subprocess.run(
                    ["git", "fetch", "--all"], cwd=self.aur_repo_path, check=True
                )
            else:
                subprocess.run(["git", "pull"], cwd=self.aur_repo_path, check=True)

    def get_refs_with_dates(self) -> List[Tuple[str, str, int]]:
        # Try refs/heads first
        result = subprocess.run(
            [
                "git",
                "for-each-ref",
                "--format=%(refname) %(committerdate:unix)",
                "refs/heads",
            ],
            cwd=self.aur_repo_path,
            capture_output=True,
            text=True,
            check=True,
        )
        print(f"refs/heads: {len(result.stdout.strip().split('\n'))} refs")
        refs = []
        for line in result.stdout.strip().split("\n"):
            if line:
                parts = line.split()
                if len(parts) >= 2:
                    full_ref, date = parts[0], int(parts[1])
                    ref_short = full_ref.split("/", 2)[
                        -1
                    ]  # Get the short name after refs/heads/
                    if ref_short.startswith("packages/"):
                        package_name = ref_short[len("packages/") :]
                    else:
                        package_name = ref_short
                    refs.append((ref_short, package_name, date))

        # If few refs/heads, try refs/remotes/origin
        if len(refs) < 1000:
            result = subprocess.run(
                [
                    "git",
                    "for-each-ref",
                    "--format=%(refname) %(committerdate:unix)",
                    "refs/remotes/origin",
                ],
                cwd=self.aur_repo_path,
                capture_output=True,
                text=True,
                check=True,
            )
            print(f"refs/remotes/origin: {len(result.stdout.strip().split('\n'))} refs")
            for line in result.stdout.strip().split("\n"):
                if line:
                    parts = line.split()
                    if len(parts) >= 2:
                        full_ref, date = parts[0], int(parts[1])
                        ref_short = full_ref.split("/", 3)[
                            -1
                        ]  # After refs/remotes/origin/
                        if ref_short.startswith("packages/"):
                            package_name = ref_short[len("packages/") :]
                        else:
                            package_name = ref_short
                        refs.append((ref_short, package_name, date))

        # Filter out invalid package names
        valid_refs = []
        invalid_names = {'HEAD', 'master', 'main', 'develop', 'trunk', 'stable'}
        for ref_short, package_name, date in refs:
            if package_name not in invalid_names and '/' not in package_name:
                valid_refs.append((ref_short, package_name, date))
        print(f"Found {len(valid_refs)} valid refs")
        return sorted(valid_refs, key=lambda x: x[2], reverse=True)  # Most recent first

    def is_package_audited(self, package_name: str, last_updated: int) -> bool:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "SELECT last_updated, status FROM packages WHERE name = ?", (package_name,)
            )
            row = cursor.fetchone()
            return row is not None and row[1] == 'audited' and row[0] >= last_updated

    def mark_package_auditing(self, package_name: str, last_updated: int):
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                "INSERT OR REPLACE INTO packages (name, last_updated, status) VALUES (?, ?, ?)",
                (package_name, last_updated, "auditing"),
            )

    def audit_package(
        self, ref: str, package_name: str, last_updated: int
    ) -> Tuple[str, dict]:
        started_at = int(time.time())
        tmpdir = Path(tempfile.mkdtemp())
        try:
            # Create worktree for the package
            subprocess.run(
                ["git", "worktree", "add", str(tmpdir), f"remotes/origin/{package_name}"],
                cwd=self.aur_repo_path,
                check=True,
            )

            # Run aur-sleuth with local clone_url and plain output
            result = subprocess.run(
                [
                    str(AUR_SLEUTH_PATH),
                    "--clone-url",
                    str(tmpdir),
                    "--output",
                    "plain",
                    package_name,
                ],
                capture_output=True,
                text=True,
            )

            finished_at = int(time.time())

            # Parse result - for simplicity, assume exit code 0 is safe, 1 is unsafe
            audit_result = "safe" if result.returncode == 0 else "unsafe"
            details = result.stdout + result.stderr

            return package_name, {
                "result": audit_result,
                "details": details,
                "started_at": started_at,
                "finished_at": finished_at,
            }
        finally:
            # Remove worktree
            subprocess.run(["git", "worktree", "remove", str(tmpdir)], cwd=self.aur_repo_path, check=False)
            import shutil
            shutil.rmtree(tmpdir, ignore_errors=True)

    def store_audit_result(
        self, package_name: str, last_updated: int, audit_data: dict
    ):
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "INSERT INTO audits (package_name, started_at, finished_at, result, details) VALUES (?, ?, ?, ?, ?)",
                (
                    package_name,
                    audit_data["started_at"],
                    audit_data["finished_at"],
                    audit_data["result"],
                    audit_data["details"],
                ),
            )
            audit_id = cursor.lastrowid
            # For now, no file details, but can be extended
            conn.execute(
                "UPDATE packages SET status = ?, last_updated = ? WHERE name = ?",
                ("audited", last_updated, package_name),
            )

    def run_audit_loop(self):
        print("Updating AUR repo...")
        self.update_aur_repo()
        print("Getting refs...")
        refs = self.get_refs_with_dates()
        print(f"Found {len(refs)} refs")
        candidates = []
        for ref, package_name, last_updated in refs:
            if not self.is_package_audited(package_name, last_updated):
                candidates.append((ref, package_name, last_updated))
        if self.max_packages:
            candidates = sorted(candidates, key=lambda x: x[2], reverse=True)[:self.max_packages]
        print(f"Processing {len(candidates)} packages.")

        with concurrent.futures.ThreadPoolExecutor(
            max_workers=self.max_parallel
        ) as executor:
            futures = []
            for ref, package_name, last_updated in candidates:
                print(f"Queueing audit for {package_name}")
                self.mark_package_auditing(package_name, last_updated)
                futures.append(
                    executor.submit(
                        self.audit_package, ref, package_name, last_updated
                    )
                )

            for future in concurrent.futures.as_completed(futures):
                try:
                    package_name, audit_data = future.result()
                    # Find last_updated for this package
                    last_updated = next(
                        (date for r, name, date in refs if name == package_name), None
                    )
                    if last_updated:
                        self.store_audit_result(package_name, last_updated, audit_data)
                    print(f"Audit completed for {package_name}: {audit_data['result']}")
                except Exception as e:
                    print(f"Audit failed: {e}")


def main():
    parser = argparse.ArgumentParser(
        description="Track and audit AUR packages using aur-sleuth."
    )
    parser.add_argument(
        "--db-path", default="aur_tracker.db", help="Path to SQLite database"
    )
    parser.add_argument(
        "--aur-repo-path", default="aur-repo", help="Path to local AUR git repo"
    )
    parser.add_argument(
        "--max-parallel", type=int, default=3, help="Maximum parallel audits"
    )
    parser.add_argument(
        "--max-packages",
        type=int,
        help="Maximum number of packages to audit (for testing)",
    )
    args = parser.parse_args()

    db_path = Path(args.db_path)
    aur_repo_path = Path(os.path.expanduser(args.aur_repo_path))

    tracker = AurTracker(db_path, aur_repo_path, args.max_parallel, args.max_packages)
    tracker.run_audit_loop()


if __name__ == "__main__":
    main()
